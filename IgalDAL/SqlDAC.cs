using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Data.SqlClient;
using System.Data;

namespace IgalDAL
{
    public static class SqlDAC
    {
        //If there is a need to override the default command timeout
        private static int m_CommandTimeOut = 30;

        private enum SqlConnectionOwnership
        {
            //Connection is owned and managed by SqlDAC
            Internal,
            // Connection is owned and managed by the caller
            External
        }// SqlConnectionOwnership

        public static SqlDataReader ExecuteReader(String connectionString, CommandType commandType, String commandText,
                                            params SqlParameter[] commandParameters)
        {
            string sAnsiNulOff = "";
            if (connectionString == null || connectionString.Length == 0)
                throw new ArgumentNullException("connectionString");

            //Create & open a SqlConnection
            SqlConnection connection = null;
            try
            {
                connection = new SqlConnection(connectionString);
                connection.Open();
                // Call the private overload that takes an internally owned connection in place of the connection string
                SqlCommand cmd = new SqlCommand(commandText, connection);
                SqlDataReader rdr;
                if (commandParameters != null)
                {
                    foreach (SqlParameter param in commandParameters)
                    {
                        //igal 30-10-19
                        if (((System.Data.SqlTypes.INullable)param.SqlValue).IsNull)
                        {
                            sAnsiNulOff = "set ANSI_NULLS off ";
                            cmd.CommandText = sAnsiNulOff + cmd.CommandText;
                        }

                        cmd.Parameters.Add(param);
                    }
                }
                cmd.CommandType = commandType;
                try
                {
                    rdr = cmd.ExecuteReader(CommandBehavior.SequentialAccess);
                }
                catch (Exception)
                {                    throw;                 }
                finally
                { cmd.Dispose(); }
                return rdr;
            }
            catch
            {
                // If we fail to return the SqlDatReader, we need to close the connection ourselves
                if (connection.State == ConnectionState.Open)
                {
                    connection.Close();
                    connection.Dispose();
                }
                throw;
            }
        }// ExecuteReader


        // Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
        // using the provided parameters.
        // e.g.:  
        // Dim ds As Dataset = ExecuteDataset(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24))
        // Parameters:
        // -connection - a valid SqlConnection
        // -commandType - the CommandType (stored procedure, text, etc.)
        // -commandText - the stored procedure name or T-SQL command
        // -commandParameters - an array of SqlParamters used to execute the command
        // Returns: A dataset containing the resultset generated by the command
        public static DataSet ExecuteDataset(SqlConnection  con, CommandType commandType, String commandText , 
                                                        params SqlParameter[]  commandParameters)
        {
            DataSet ds = new DataSet();

            try
            {
                if (con.State == ConnectionState.Closed) con.Open();

                // Create a command and prepare it for execution            
                
                SqlDataAdapter dataAdatpter = null;
                SqlCommand cmd;

                switch (commandType)
                {
                    case CommandType.StoredProcedure:
                    case CommandType.Text:
                        break;
                    case CommandType.TableDirect:
                        commandType = CommandType.Text;
                        commandText = "select * from " + commandText;
                        break;
                    default:
                        break;
                }
                cmd = new SqlCommand(commandText, con);
                cmd.CommandType = commandType;

                //igal 19-5-19
                if (m_CommandTimeOut == 0 || con.ConnectionTimeout == 0)
                    cmd.CommandTimeout = 0;
                else
                {
                    if (con.ConnectionTimeout > m_CommandTimeOut)
                        cmd.CommandTimeout = con.ConnectionTimeout;
                    else
                        cmd.CommandTimeout = m_CommandTimeOut;
                }

                if (commandParameters != null)
                {
                    foreach (SqlParameter param in commandParameters)
                    {
                        cmd.Parameters.Add(param);
                    }
                }
                try
                {   // Create the DataAdapter & DataSet
                    dataAdatpter = new SqlDataAdapter(cmd);

                    // Fill the DataSet using default values for DataTable names, etc
                    dataAdatpter.Fill(ds);
                }
                catch (System.Data.SqlClient.SqlException ex)
                { throw ex; }
            finally
                // Detach the SqlParameters from the command object, so they can be used again
                { cmd.Parameters.Clear(); }

                if (dataAdatpter != null) dataAdatpter.Dispose();

            }
            catch (Exception ex)
            {   throw ex ;  }

            // Return the dataset
            return ds;
        }

        public static DataSet ExecuteDataset(string connectionString, CommandType commandType, String commandText , 
                                                        params SqlParameter[]  commandParameters) 
        {
            SqlConnection connection = new SqlConnection(connectionString);
            try
            {
                connection.Open();
                connection.InfoMessage += con_InfoMessage;
                return ExecuteDataset(connection, commandType, commandText, commandParameters);
            }
            catch (Exception ex)
            {   throw ex;   }
            finally
            { if (connection.State == ConnectionState.Open) connection.Close(); }                                
            
        }

        //igal 2/9/19 - catch the print messages from sql console
        static void con_InfoMessage(object sender, SqlInfoMessageEventArgs e)
        {
            // this gets the print statements (maybe the error statements?)
            OutputFromScript += e.Message;
        }

        static public string OutputFromScript { get; set; }

        // ExecuteDataset

        public static void SetCommandTimeOut(int prTimeOut)
        {            m_CommandTimeOut = prTimeOut;        }

        public static void SetCommandtimeOutDefault()
        {           m_CommandTimeOut = 30;                }

        public static int TimeOut 
        { 
            get {return m_CommandTimeOut;}
            set { m_CommandTimeOut = value; }
        }


        // Execute a SqlCommand (that returns no resultset) against the specified SqlTransaction
        // using the provided parameters.
        // e.g.:  
        // Dim result As Integer = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24))
        // Parameters:
        // -transaction - a valid SqlTransaction 
        // -commandType - the CommandType (stored procedure, text, etc.) 
        // -commandText - the stored procedure name or T-SQL command 
        // -commandParameters - an array of SqlParamters used to execute the command 
        // Returns: An int representing the number of rows affected by the command 

        public static int ExecuteNonQuery(String connectionString, CommandType commandType, String commandText, params SqlParameter[] commandParameters)
        {
            SqlConnection con = new SqlConnection(connectionString);
            try
            {
                con.Open();
                return ExecuteNonQuery(con, commandType, commandText, commandParameters);
            }
            catch (Exception)
            {
                throw;
            }
            finally
            { if (con.State == ConnectionState.Open) con.Close(); }            
        }

        public static int ExecuteNonQuery(SqlConnection con, CommandType commandType, String commandText, params SqlParameter[] commandParameters) 
        {
            //If (transaction Is Nothing) Then Throw New ArgumentNullException("transaction")
            //If Not (transaction Is Nothing) AndAlso (transaction.Connection Is Nothing) Then Throw New ArgumentException("The transaction was rollbacked or commited, please provide an open transaction.", "transaction")

            // Create a command and prepare it for execution
            SqlCommand cmd =new SqlCommand();
            int retval ;
            bool mustCloseConnection = false;

            //PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters, mustCloseConnection)

            // Finally, execute the command
            try
            {
                if (con.State == ConnectionState.Closed) con.Open();
                
                cmd.CommandType = commandType;
                cmd.CommandText = commandText;
                cmd.CommandTimeout = m_CommandTimeOut;
                cmd.Connection = con;
                if (commandParameters != null)
                {
                    foreach (SqlParameter param in commandParameters)
                    {
                        cmd.Parameters.Add(param);
                    }
                }
                retval = cmd.ExecuteNonQuery();                
            }
            catch (Exception ex )
                {throw ex; }
            finally
                // Detach the SqlParameters from the command object, so they can be used again
            {
                cmd.Parameters.Clear();                
            }
                
            return retval;
        }// ExecuteNonQuery

        public static Object ExecuteScalar(string connectionString, CommandType commandType, String commandText, params SqlParameter[] commandParameters)
        {          
            SqlConnection con = new SqlConnection(connectionString);            

            try
            {
                con.Open();
                return ExecuteScalar(con, commandType, commandText, commandParameters);
            }
            catch (Exception ex)
            {
                throw ex;
            }
            finally
            { if (con.State == ConnectionState.Open) con.Close(); }

        }

        public static Object ExecuteScalar(SqlConnection connection, CommandType commandType, String commandText, params SqlParameter[] commandParameters) 
        {

            if (connection == null) 
                throw new ArgumentNullException("connection");

            // Create a command and prepare it for execution
            SqlCommand cmd = new SqlCommand();
            Object retval;
            Boolean mustCloseConnection = false;
            try
            {
                cmd.CommandType = commandType;
                cmd.CommandText = commandText;
                cmd.CommandTimeout = m_CommandTimeOut;
                cmd.Connection = connection;

                if (commandParameters != null)
                {
                    foreach (SqlParameter param in commandParameters)
                    {
                        cmd.Parameters.Add(param);
                    }
                }

                // Execute the command & return the results
                retval = cmd.ExecuteScalar();
            }
            catch (SqlException ex )
                {   throw ex;   }
            finally
            {
                // Detach the SqlParameters from the command object, so they can be used again
                cmd.Parameters.Clear();
                cmd.Dispose();
                if (mustCloseConnection) 
                    connection.Close();
            }
            return retval;

            } // ExecuteScalar

        public static bool ParseSql(string connectionString, String commandText, out string ErrMsg)
        {      
            int retval;

            ErrMsg = "";
            try
            {
                StringBuilder newCommand = new StringBuilder();
                newCommand.AppendLine("set parseonly on ");
                newCommand.AppendLine(commandText);                 
                SqlParameter param = new SqlParameter("retval", SqlDbType.VarChar, 4000);
                param.Direction = ParameterDirection.ReturnValue;

                retval = ExecuteNonQuery(connectionString, CommandType.Text, newCommand.ToString(), param);
                return true;
            }
            catch(Exception ex)
            {
                ErrMsg = ex.Message;
                return false;
            }
            
        }
    }
}
